<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeGlyph - Á†Å‰∏äÁîüËä±</title>
    <style>
        :root {
            --primary-color: #007aff;
            --primary-hover-color: #0056b3;
            --danger-color: #dc3545;
            --danger-hover-color: #c82333;
            --light-gray-color: #f8f9fa;
            --medium-gray-color: #dee2e6;
            --dark-gray-color: #6c757d;
            --dark-gray-hover-color: #5a6268;
            --text-color: #212529;
            --text-muted-color: #666;
            --bg-color: #fff;
            --border-light-color: #eee;
            --disabled-color: #aaa;
            --success-color: #28a745;
            --border-radius: 8px;
        }
        [data-theme="dark"] {
            --primary-color: #4da3ff;
            --primary-hover-color: #7ab8ff;
            --danger-color: #ff6b7a;
            --danger-hover-color: #ff8a96;
            --light-gray-color: #1e1e1e;
            --medium-gray-color: #3a3a3a;
            --dark-gray-color: #a0a0a0;
            --dark-gray-hover-color: #b0b0b0;
            --text-color: #e0e0e0;
            --text-muted-color: #999;
            --bg-color: #2a2a2a;
            --border-light-color: #444;
            --disabled-color: #555;
            --success-color: #4ade80;
        }
        [data-theme="dark"] select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23a0a0a0' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
        }
        [data-theme="dark"] input[type="text"],
        [data-theme="dark"] textarea,
        [data-theme="dark"] select {
            color: var(--text-color);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 5vh;
            margin: 0;
            background-color: var(--light-gray-color);
            color: var(--text-color);
        }
        .container {
            position: relative;
            text-align: center;
            padding: 20px 25px;
            border-radius: var(--border-radius);
            background-color: var(--bg-color);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            width: 90%;
            max-width: 420px;
        }
        h1 {
            font-size: 4.5rem;
            margin: 15px 0 0 0;
            color: var(--text-color);
            min-height: 70px;
            font-weight: 600;
        }
        .app-title {
            font-size: 1.8rem;
            min-height: auto;
            color: var(--primary-color);
            letter-spacing: 2px;
        }
        #hint-display {
            font-size: 1.1rem;
            color: var(--dark-gray-color);
            margin-top: 5px;
            min-height: 1.5em;
            transition: all 0.3s;
        }
        #stats {
            margin-top: 15px;
        }
        #stats p {
            font-size: 0.9rem;
            margin: 0;
        }
        .status-success { color: var(--success-color) !important; }
        .status-error { color: var(--danger-color) !important; }
        #typing-input {
            font-family: 'SF Mono', 'Menlo', 'Monaco', monospace;
            letter-spacing: 2px;
            text-align: center;
            font-size: 1.4rem;
        }
        input[type="text"], textarea, select {
            display: block;
            box-sizing: border-box;
            margin: 10px auto;
            width: 100%;
            font-size: 0.9rem;
            padding: 8px 10px;
            border: 1px solid var(--medium-gray-color);
            border-radius: var(--border-radius);
            transition: border-color 0.2s, box-shadow 0.2s;
            background-color: var(--light-gray-color);
        }
        input[type="text"]:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25);
        }
        .setup-section {
            display: flex; flex-direction: column;
            gap: 12px; align-items: center; margin-top: 15px;
        }
        .setup-row {
            display: flex; align-items: center;
            justify-content: flex-start; gap: 15px;
            width: 100%;
        }
        .setup-row label {
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
        }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 16px 12px;
            flex-grow: 1;
        }
        button {
            width: 100%;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 8px 10px;
            border-radius: var(--border-radius);
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:disabled { background-color: var(--disabled-color); cursor: not-allowed; transform: none; box-shadow: none; border-color: transparent; color: var(--text-color); }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--primary-hover-color);
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: var(--dark-gray-color);
            color: white;
        }
        .btn-secondary:hover {
            background-color: var(--dark-gray-hover-color);
            transform: translateY(-1px);
        }
        #clear-progress-btn {
            width: auto;
            padding: 6px 12px;
            font-size: 0.8rem;
            background-color: var(--light-gray-color);
            color: var(--dark-gray-color);
            border-color: var(--medium-gray-color);
        }
        #clear-progress-btn:hover {
            background-color: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
            transform: translateY(-1px);
        }
        #exit-practice-btn {
            position: absolute; top: 15px; left: 15px;
            width: auto; padding: 5px 12px;
            font-size: 0.9rem; font-weight: 500;
            background-color: transparent; border: none;
            color: var(--dark-gray-color);
        }
        #exit-practice-btn:hover { background-color: var(--light-gray-color); transform: none; }
        .setup-section[style*="grid"] {
            margin-top: 12px;
            gap: 8px;
        }
        #dict-upload {
            display: none;
        }
        .icon-btn {
            width: 36px;
            height: 36px;
            min-width: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--light-gray-color);
            border: 1px solid var(--medium-gray-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s;
        }
        .icon-btn:hover {
            background-color: var(--medium-gray-color);
            transform: translateY(-1px);
        }
        .icon-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--dark-gray-color);
        }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } }
        .shake { animation: shake 0.5s ease-in-out; }
        #theme-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            padding: 0;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1.2rem;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        #theme-toggle:hover {
            opacity: 1;
            transform: none;
        }
    </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle" title="ÂàáÊç¢Ê∑±Ëâ≤Ê®°Âºè">‚òÄÔ∏è</button>
    <button id="exit-practice-btn" style="display: none;">‚Üê ËøîÂõû</button>
    <div id="character-display"><h1 class="app-title">Á†Å‰∏äÁîüËä±</h1></div>
    <div id="hint-display"></div>
    <div id="input-area" style="display: none;">
      <input type="text" id="typing-input" placeholder="Âú®Ê≠§ËæìÂÖ•ÁºñÁ†Å" autofocus>
    </div>

    <div class="setup-section">
      <div class="setup-row">
        <label for="dict-select">Á†ÅË°®:</label>
        <select id="dict-select">
          <option value="feidan">È£ûÂçï</option>
        </select>
        <button id="upload-dict-btn" class="icon-btn" title="‰∏ä‰º†Ëá™ÂÆö‰πâÁ†ÅË°®">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
        </button>
        <input type="file" id="dict-upload" accept=".yaml,.txt" multiple>
      </div>
      <div class="setup-row">
        <label for="text-select">ÊñáÊú¨:</label>
        <select id="text-select">
            <option value="custom">Ëá™ÂÆö‰πâÁ≤òË¥¥</option>
            <option value="top500">Â∏∏Áî®Ââç500Â≠ó</option>
            <option value="mid500">Â∏∏Áî®‰∏≠500Â≠ó</option>
            <option value="last500">Â∏∏Áî®Âêé500Â≠ó</option>
            <option value="top1000">Â∏∏Áî®Ââç1000Â≠ó</option>
            <option value="top1500">Â∏∏Áî®Ââç1500Â≠ó</option>
        </select>
      </div>
      <div id="custom-text-controls" style="width: 100%;">
        <textarea id="practice-text-input" placeholder="ËØ∑Âú®Ê≠§Â§ÑÁ≤òË¥¥ÊàñÈÄâÊã©È¢ÑËÆæÊñáÊú¨..."></textarea>
      </div>
      <button id="start-practice-btn" class="btn-primary">ÂºÄÂßãÁªÉ‰π†</button>
    </div>

    <div id="stats" style="margin-top: 20px; color: var(--text-muted-color);">
      <p>ÊÄªÂ≠óÊï∞: <span id="total-chars">0</span> | ÂæÖÁªÉ‰π†: <span id="pending-chars">0</span></p>
    </div>
    <div id="session-stats" style="display: none; margin-top: 15px; color: var(--text-muted-color);">
      <p>Ê≠£Á°Æ: <span id="session-correct" style="color: var(--success-color);">0</span> | ÈîôËØØ: <span id="session-wrong" style="color: var(--danger-color);">0</span> | Ê≠£Á°ÆÁéá: <span id="session-accuracy">0%</span></p>
    </div>
    <div class="setup-section" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-light-color); width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button id="import-progress-btn" class="btn-secondary">ÂØºÂÖ•ËøõÂ∫¶</button>
        <button id="export-progress-btn" class="btn-secondary">ÂØºÂá∫ËøõÂ∫¶</button>
        <input type="file" id="import-file-input" accept=".json" style="display: none;">
    </div>
    <div style="margin-top: 10px; text-align: center;">
        <button id="clear-progress-btn">Ê∏ÖÁ©∫ËøõÂ∫¶</button>
    </div>
  </div>

  <script>
    const DOM = {
      characterDisplay: document.getElementById('character-display').querySelector('h1'),
      hintDisplay: document.getElementById('hint-display'),
      typingInput: document.getElementById('typing-input'),
      dictSelect: document.getElementById('dict-select'),
      textSelect: document.getElementById('text-select'),
      dictUpload: document.getElementById('dict-upload'),
      uploadDictBtn: document.getElementById('upload-dict-btn'),
      practiceTextInput: document.getElementById('practice-text-input'),
      startPracticeBtn: document.getElementById('start-practice-btn'),
      totalCharsSpan: document.getElementById('total-chars'),
      pendingCharsSpan: document.getElementById('pending-chars'),
      customTextControls: document.getElementById('custom-text-controls'),
      setupSection: document.querySelector('.setup-section'),
      inputArea: document.getElementById('input-area'),
      clearProgressBtn: document.getElementById('clear-progress-btn'),
      exitPracticeBtn: document.getElementById('exit-practice-btn'),
      importProgressBtn: document.getElementById('import-progress-btn'),
      exportProgressBtn: document.getElementById('export-progress-btn'),
      importFileInput: document.getElementById('import-file-input'),
      sessionStats: document.getElementById('session-stats'),
      sessionCorrect: document.getElementById('session-correct'),
      sessionWrong: document.getElementById('session-wrong'),
      sessionAccuracy: document.getElementById('session-accuracy'),
      themeToggle: document.getElementById('theme-toggle'),
    };

    const PREDEFINED_TEXTS = {
      top500: 'ÁöÑ‰∏ÄÊòØ‰∫Ü‰∏çÂú®Êúâ‰∏™‰∫∫Ëøô‰∏ä‰∏≠Â§ß‰∏∫Êù•ÊàëÂà∞Âá∫Ë¶Å‰ª•Êó∂ÂíåÂú∞‰ª¨ÂæóÂèØ‰∏ãÂØπÁîü‰πüÂ≠êÂ∞±ËøáËÉΩ‰ªñ‰ºöÂ§öÂèëËØ¥ËÄå‰∫éËá™‰πãÁî®Âπ¥Ë°åÂÆ∂ÊñπÂêé‰ΩúÊàêÂºÄÈù¢‰∫ãÂ•ΩÂ∞èÂøÉÂâçÊâÄÈÅìÊ≥ïÂ¶ÇËøõÁùÄÂêåÁªèÂàÜÂÆöÈÉΩÁÑ∂‰∏éÊú¨ËøòÂÖ∂ÂΩìËµ∑Âä®Â∑≤‰∏§ÁÇπ‰ªéÈóÆÈáå‰∏ªÂÆûÂ§©È´òÂéªÁé∞ÈïøÊ≠§‰∏âÂ∞ÜÊó†ÂõΩÂÖ®ÊñáÁêÜÊòéÊó•‰∫õÁúãÂè™ÂÖ¨Á≠âÂçÅÊÑèÊ≠£Â§ñÊÉ≥Èó¥ÊääÊÉÖËÄÖÊ≤°ÈáçÁõ∏ÈÇ£ÂêëÁü•Âõ†Ê†∑Â≠¶Â∫îÂèàÊâã‰ΩÜ‰ø°ÂÖ≥‰ΩøÁßçËßÅÂäõÂêç‰∫åÂ§ÑÈó®Âπ∂Âè£‰πàÂÖà‰ΩçÂ§¥ÂõûËØùÂæàÂÜçÁî±Ë∫´ÂÖ•ÂÜÖÁ¨¨Âπ≥Ë¢´ÁªôÊ¨°Âà´Âá†ÊúàÁúüÁ´ãÊñ∞ÈÄöÂ∞ëÊú∫ÊâìÊ∞¥ÊûúÊúÄÈÉ®‰ΩïÂÆâÊé•Êä•Â£∞Êâç‰Ωì‰ªäÂêàÊÄßË•ø‰Ω†ÊîæË°®ÁõÆÂä†Â∏∏ÂÅöÂ∑±ËÄÅÂõõ‰ª∂Ëß£Ë∑ØÊõ¥Ëµ∞ÊØîÊÄªÈáëÁÆ°ÂÖâÂ∑•ÁªìÊèê‰ªª‰∏úÂéü‰æøÁæéÂèäÊïôÈöæ‰∏ñËá≥Ê∞îÁ•ûÂ±±Êï∞Âà©‰π¶‰ª£Áõ¥Ëâ≤Âú∫ÂèòËÆ∞Âº†ÂøÖÂèó‰∫§ÈùûÊúçÂåñÊ±ÇÈ£éÂ∫¶Â§™‰∏áÂêÑÁÆóËæπÁéã‰ªÄÂø´ËÆ∏Ëøû‰∫îÊ¥ªÊÄùËØ•Ê≠•Êµ∑ÊåáÁâ©ÂàôÂ•≥ÊàñÂÆåÈ©¨Âº∫Ë®ÄÊù°ÁâπÂëΩÊÑüÊ∏ÖÂ∏¶ËÆ§‰øùÊúõËΩ¨‰º†ÂÑøÂà∂Âπ≤ËÆ°Ê∞ëÁôΩ‰ΩèÂ≠óÂÆÉ‰πâËΩ¶ÂÉèÂèçË±°È¢òÂç¥ÊµÅ‰∏îÂç≥Ê∑±ËøëÂΩ¢ÂèñÂæÄÁ≥ªÈáèËÆ∫ÂëäÊÅØËÆ©ÂÜ≥Êú™Ëä±Êî∂Êª°ÊØèÂçé‰∏öÂçóËßâÁîµÁ©∫ÁúºÂê¨ËøúÂ∏àÂÖÉËØ∑ÂÆπÂ•πÂÜõÂ£´ÁôæÂäûËØ≠ÊúüÂåóÊûóËØÜÂçäÂ§´ÂÆ¢ÊàòÈô¢ÂüéÂÄôÂçïÈü≥Âè∞Ê≠ªËßÜÈ¢ÜÂ§±Âè∏‰∫≤ÂßãÊûÅÂèå‰ª§ÊîπÂäüÁ®ãÁà±Âæ∑Â§çÂàáÈöèÊùéÂëòÁ¶ªËΩªËßÇÈùíË∂≥ËêΩÂè´Ê†πÊÄéÊåÅÁ≤æÈÄÅ‰ºóÂΩ±ÂÖ´È¶ñÂåÖÂáÜÂÖ¥Á∫¢ËææÊó©Â∞ΩÊïÖÊàøÂºïÁÅ´Á´ô‰ººÊâæÂ§áË∞ÉÊñ≠ËÆæÊ†ºÊ∂àÊãâÁÖßÂ∏ÉÂèãÊï¥ÊúØÁü≥Â±ïÁ¥ßÊçÆÁªàÂë®Âºè‰∏æÈ£ûÁâáËôΩÊòìËøêÁ¨ë‰∫ëÂª∫Ë∞àÁïåÂä°ÂÜôÈí±ÂïÜ‰πêÊé®Ê≥®Ë∂äÂçÉÂæÆËã•Á∫¶Ëã±ÈõÜÁ§∫Âë¢ÂæÖÂùêËÆÆ‰πéÁïôÁß∞ÂìÅÂøóÈªëÂ≠òÂÖ≠ÈÄ†‰ΩéÊ±üÂøµ‰∫ßÂàªËäÇÂ∞îÂêÉÂäø‰æùÂõæÂÖ±ÊõæÂìçÂ∫ïË£ÖÂÖ∑Âñú‰∏•‰πùÂÜµË∑üÁΩóÈ°ªÊòæÁÉ≠ÁóÖËØÅÂàöÊ≤ªÁªùÁæ§Â∏ÇÈò≥Á°ÆÁ©∂‰πÖÈô§ÈóªÁ≠îÊÆµÂÆòÊîøÁ±ªÈªÑÊ≠¶‰∏ÉÊîØË¥πÁà∂Áªü',
      mid500: 'Â∫úÊü•Ëà¨ÊñØÂÄíÁ™ÅÂè∑Ê†ëÊãøÂÖãÂàùÂπøÂ•áÊÑøÊ¨¢Â∏åÊØçÈ¶ôÁ†¥Ë∞ÅËá¥Á∫øÊÄ•Âè§Êó¢Âè•‰∫¨Áîö‰ªçÊôö‰∫âÊ∏∏Èæô‰ΩôÊä§Âè¶Âô®ÁªÜÊú®ÊùÉÊòüÂì™Ëã¶Â≠©ËØïÊúùÈòøÈòüÂ±ÖÂÆ≥Áã¨ËÆ≤ÈîôÂ±ÄÁî∑Â∑ÆÂèÇÁ§æÊç¢ÈÄâÊ≠¢ÈôÖÂÅáÊ±âÂ§üËØâËµÑÂØÜÊ°àÂè≤ËæÉÁéØÊäïÈùôÂÆù‰∏ì‰øÆÂÆ§Âå∫ÊñôÂ∏ÆË°£Á´üÊ®°ËÑ∏ÂñÑÂÖµËÄÉËßÑËÅîÂõ¢ÂÜ∑ÁéâÊñΩÊ¥æÁ∫™ÈááÂéÜÈ°æÊò•Ë¥£Â§úÁîªÊÉäÈì∂Ë¥üÁª≠ÂêóÁÆÄÁ´†Â∑¶ÂùóÁ¥¢ÈÖíÂÄºÊÄÅÊåâÈôàÊ≤≥Â∑¥ÂÜ≤ÈòµÂ¢ÉÂä©ËßíÊà∑‰π±ÂëºÁÅµËÑöÁªßÊ•ºÊôØÊÄïÂÅúÈìÅÂºÇË∞¢Âê¶‰º§Ëò≠ÁΩÆÂåªËâØÊâøÁ¶èÁßëÂ±ûÂõ¥ÈúÄÈÄÄÂü∫Âè≥ÈÄüÈÄÇËçØÊÄÄÂáª‰π∞Á¥†ËÉåÂ≤ÅÂúüÂøôÂÖÖÊéí‰ª∑Ë¥®ÈÅáÁ´ØÂàóÂç∞Ë¥µÁñëÈú≤Âì•ÊùÄÊ†áÊãõË°ÄÁ§ºÂºü‰∫ÆÈΩêÁ©øËÑëÂßîÂ∑ûÊüêÈ°∫ÁúÅËÆ®Â∞öÁª¥ÊùøÊï£È°πÁä∂ËøΩÁ¨îÂâØÂ±ÇÊ≤ôÂÖªËØª‰π†Ê∞∏ËçâËÉ°ÊµéÊâßÂØüÂΩíÂØåÂ∫ßÈõ®Â†ÇÂ®ÅÂøΩËãèËàπÁΩ™Êï¢Â¶áÊùëËëóÈ£üÂØºÂÖçÊ∏©Ëé´ÊéåÊøÄÊÖ¢ÊâòËÉúÈô©ÂØªÂÆàÊ≥¢Èõ∑Ê≤âÁßÄËÅåÈ™åÈù†Ê•öÁï•ÊóèËóè‰∏ΩÊ∏êÂàò‰ªÖËÇØÊãÖÊâ¨ÁõòÂîêÈíüÁ∫ßÊØõËê•ÂùöÊùæÁöÆ‰æõÂ∫óÈ•≠ËåÉÂìàËµ∂ÂêßÈõ™ÊñóÊïà‰∏¥ÂÜúÂë≥ÊÅ∂ÁÉüÂõ≠ÁÉàÈÖçÊùÇÁü≠Âç´Ë∑≥Â≠ôÊõ≤Â∞ÅÊäìÁßªÈ°øÂæãÂçñËâ∫ÊóßÊúãÊïëÈò≤ËÑ±ÁøªÂàíËøéÁóõÊ†°Á™óÂÆ£‰π°Êù®Âè∂Ë≠¶ÈôêÊπñËΩØÊéâË¥¢ËØçÂéãÊå•Ë∂ÖÂ±ãÁßãË∑ëÂøòÈ¶ÜÊöóÁè≠ÂÖöÂÆóÂùèÊäÄÂõ∞ÁôªÂßêÈ¢ÑËÄ≥Â∏≠Ê¢¶Êú±ÁªÑÊóÅ‰ªΩÁ¶ÅÂ•ó‰∫öÁõäÊé¢Â∫∑Â¢ûËØóÊàè‰ºØÊôìÂê´Âä≥ÊÅ©È°∂ÂêõÂ∫ÑË∞ì‰ªòÁî∞ÊØïÁ∫∏Á†îËôöÊÄ™ÂÆÅÊõøÁäØÁÅØ‰ºòÊÇ®Âßì‰æã‰∏ùÁõñËØØÊû∂Âπ∏ÈöêËÇ°ÊØíÂ®òÂç†Êô∫‰ΩõÂ∫äÁ±≥Âá°‰ªãÂæÅÂΩ©ÊºîÂ∞ÑÁ•ñÊ¨≤ÊùüËé∑ËàûÂú£‰ºôÊ¢ÖÊôÆÂÄüÁßÅÊ∫êÈïáÁù°ÁºìÂçáÁ∫≥ÁªáÊ≠åÂÆ´Ê¶ÇÈáéÈÜíÂ§è‰∫íÁßØË°óÁâå‰ºëÊëáÊ¥ãË¥•ÁõëÈ™®ÊâπÂÖÑÂàÄÁΩëÁéáÂ∫≠ÁÜüÂàõËÆøÁ°¨‰ªÅËèú‰∏ÅÁªøÁâõÈÅøÈò¥ÊãçÈõÑÁßòÁº∫Âç∑ÂßëÂ∞ºÊ≤πÊÅêÁé©ÈáäÈÅçÊè°ÁêÉÈôçËôëËç£Á≠ñËÇâÂ¶àËø∑Ê£Ä‰º∏Ê¨ßÊîªÁªÉËÇ≤Âç±ÂéÖÂïäÁùõÊëÜËå∂ÂãáÂà§ÊùêÊä±‰∫¶Â¶ªÂê∏ÂñùË∂£Âò¥ÈÄêÊìçÂçàÂêâÊµ™ËΩÆÈªòÊØ´ÂÜ∞',
      last500: 'Áè†ÈºìÈò∂Â≠îÂæêÂõ∫ÂÅèÈôÜËØ∏ÈÅóÁà∑Ëø∞Â∏ùÈó≠Ë°•ÁºñÂ∑®ÈÄèÂºÑÂ∞§È≤ÅÊã•ÂΩïÂê¥Â¢ôË¥ßÂº±ÊïåÊåëÂÆΩËøπÊäΩÂøçÊäòËæìÁ®≥ÁöáÊ°åÁåÆËíôÁ∫∑È∫ªÊ¥óËØÑÊåÇÁ´•Â∞äËàçÂîØÂçöÂâß‰πÉÊ∑∑ÂºπÈôÑËøüÊï¨ÊùØÈ±ºÊéßÂ°ûÂâëÂéö‰Ω≥ÊµãËÆ≠ÁâôÊ¥ûÊ∑°ÁõõÂéøËä≥ÈõÖÈù©Ê¨æÊ®™Á¥ØÊã©‰πòÂà∫ËΩΩÁåõÈÄÉÊûÑËµµÊùúÂ∫ÜÈÄîÂ•îËôéÂ∑ßÊäóÈíàÂæíÂúÜÈó™Ë∞∑ÁªçËÅöÈ¢ùÂÅ•ËØöÈ≤úÊ≥™Èó≤ÂùáÂ∫èÈúá‰ªøÁºòÊà¥Â©öÁØá‰∫°Â•∂Âø†ÁÉ¶ËµõÈóπÂçèÊù∞ÊÆãÊáÇ‰∏πÊü≥Â¶πÊò†Ê°•ÂèπÊÑàÊóÖÊéà‰∫´Êö¥ÂÅ∑ËìùÊ∞èÂØíÂÆúÂºÉ‰∏∞Âª∂ËæàÊä¢È¢úËµûÂÖ∏ÂÜíÁúâÁÉßÂéÇÂî±ÂæÑÂ∫ìÂ∑ùËæû‰º¥ÊÄíÂûãÁ∫ØË¥ùÁ•®ÈöîÁ©∑ÊãúÂÆ°‰º¶ÊÇ≤ÊüîÂêØÂáèÈ°µÁ∫µÊâ´‰ºüËø´ÊåØÁëû‰∏àÊ¢ÅÊ¥≤Êû™Â§ÆËß¶‰∫àÂ≠§Áº©Ê¥õÊçü‰øÉÁï™ÁΩ¢ÂÆãÂ•ãÈîÄÂπïÁäπÈîÅÁèçÊä¨Èô™Â¶ôÊë∏Â≥∞Âä≤ÈïúÊ≤àÂ§∫Êò®Âì≠ËÆØË≤åË∞ãÊ≥∞‰æßË¥´Êâ∂ÈòªË¥¥Áî≥Â≤∏ÂΩºËµèÁâàÊäµÊ≥ΩÊèíËøÖÂá≠‰ºäÊΩÆÂí±‰ªôÁ¨¶ÂÆáËÇ©Â∞ùÈÄíÁáïÊ¥ÅÊãíÈÉéÂáùÂáÄÈÅ≠‰ª™ËñÑÂç°Êú´Âãí‰πåÊ£ÆËØ∫ÂëÄÂ£ÆÂøßÊ≤øÊÉØ‰∏¢Â≠£‰ºÅÂ£ÅÊÉúÂ©ÜË¢ãÊúóÈõ∂ËæõÂøÜÂä™ËàíÊûùÂá§ÁÅ≠Èü©ËÉÜÁÅ∞Êó¶Â≠üÈô∑‰øóÁªïÁñæÁûßÊ¥™Áî≤Â∏êÁ≥äÊ≥õÁöÜÁ¢∞ÂêπÁ†ÅÂ•âÁÆ±ÂÄæËÉ∏Â†ÜÁãÇ‰ª≤ÂúàÂÜ¨È§êÂéâËÖøÂ∞ñÊã¨‰Ω©È¨ºÊ¨£ÂûÇË∑ÉÊ∏ØÈ™óËûçÊíûÂ°îÁ¥´Ëç°ÊïèÈÉëËµñÊªëÂÖÅÈ∏üËØæÊöÇÁì¶Á••ÊüìÊªöÊµÆÁ≤óÂàëËæÜÁãóÊâëÁ®çÁß¶ÊâéÈ≠ÇÂ≤õËÖæËá£Áê¥ÊÇâÁªúÊë©Êé™ÂüüÂÜ†Á´πÊÆäË±™ÂëÜËê®ÊóãÂñäÂØÑÊÇÑÂÄçÁ•ùÂâ©Áù£ÊóóËøîÂè¨ÂΩªÂÆæÁîòÂêê‰πîËÖ∞ÊãîÂπÖËøùËØ¶ËáÇÂ∞∫È•ÆÈ¢óÊ∂âÈÄºÁ´ûÂüπÊÉ†‰∫èÂèî‰ºèÂî§È∏°ÈÇªÊ±†ÊÄ®Â••‰æØÈ™ëÊº´Êãñ‰øäÂ∞æÊÅ®Ë¥ØÂáåÂÖºËØ¢Á¢éÊô®ÁΩöÈì∫Êµì‰ºçÂÆøÊ≥â‰∫ïÁπÅÁ≤âÁª™Á≠ëÊÅ¢ÂåπÂ∞òËæâÈ≠î‰ª∞Ëë£ÊèèË∑ùÁõóÊ∏°Âã§ÂäùËé≤Âù¶Êê≠Êå∫Ë∏™ÂπΩÊà™ËçíÊÅ∞ÊÖßÈÇ¶È¢áÁÑ¶ÈÜâÂ∫üÊé©Á≠æ‰∏ßÁÅæÈºª‰æµÈô∂ËÇÉË£Å‰ø±Á£®ÊûêÂ•ñÂåÜÁì∂Ê≥•ÊãæÂáâÈ∫¶Èí¢Ê∂åÊΩúÈöÜÊ¥•ÊêûËõãÂ•àÊâ∞ËÄêÂÇÖÈî¶Êí≠Â¢®ÂÅ∂ÊçïÊÉëÈ£òÂ±àÈ∏£Êå§ÊØÅÊñúÂï¶Ê±°Ëµ§ÊÖ∞È•∞ÈîãË¶ÜÊ±§ÂØøË∑®Áæä'
    };
    PREDEFINED_TEXTS.top1000 = (PREDEFINED_TEXTS.top500 || '') + (PREDEFINED_TEXTS.mid500 || '');
    PREDEFINED_TEXTS.top1500 = (PREDEFINED_TEXTS.top500 || '') + (PREDEFINED_TEXTS.mid500 || '') + (PREDEFINED_TEXTS.last500 || '');

    const PREDEFINED_DICTS = {feidan: ['https://raw.githubusercontent.com/sbsrf/sbsrf/refs/heads/main/sbxlm/sbfd.dict.yaml', 'https://raw.githubusercontent.com/sbsrf/sbsrf/refs/heads/main/sbxlm/sbf.dict.yaml']};

    let dictionary = {}, practiceSet = [];
    let currentCharacter = null;
    let currentProfile = {};
    let currentProfileId = 'feidan';
    let sessionMistakeQueue = [];
    let customDictName = '';
    let sessionCorrectCount = 0;
    let sessionWrongCount = 0;

    function getCharStat(char) {
        if (!currentProfile[char]) {
            currentProfile[char] = { successCount: 0, failCount: 0, lastPracticed: 0, interval: 1, nextReview: 0 };
        }
        return currentProfile[char];
    }

    function getNextChar() {
        const now = Date.now();
        
        // Priority 1: Review mistakes from current session
        if (sessionMistakeQueue.length > 0 && Math.random() < 0.6) {
            const char = sessionMistakeQueue.shift();
            if (practiceSet.includes(char)) return char;
        }
        
        // Priority 2: Characters due for review (sorted by urgency)
        const dueChars = practiceSet
            .filter(char => getCharStat(char).nextReview <= now && getCharStat(char).successCount > 0)
            .sort((a, b) => getCharStat(a).nextReview - getCharStat(b).nextReview);
        
        if (dueChars.length > 0 && Math.random() < 0.7) {
            return dueChars[0];
        }
        
        // Priority 3: New characters (never practiced)
        const newChars = practiceSet.filter(char => getCharStat(char).successCount === 0 && getCharStat(char).failCount === 0);
        if (newChars.length > 0 && Math.random() < 0.5) {
            return newChars[Math.floor(Math.random() * Math.min(5, newChars.length))];
        }
        
        // Priority 4: Weighted random selection
        const weights = practiceSet.map(char => {
            const stat = getCharStat(char);
            const timeSinceReview = now - stat.lastPracticed;
            const failWeight = 1 + stat.failCount * 2;
            const timeWeight = Math.min(3, timeSinceReview / (stat.interval * 60000 * 0.5));
            return Math.max(0.1, failWeight * timeWeight);
        });
        
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let random = Math.random() * totalWeight;
        
        for (let i = 0; i < practiceSet.length; i++) {
            random -= weights[i];
            if (random <= 0) return practiceSet[i];
        }
        
        return practiceSet[Math.floor(Math.random() * practiceSet.length)];
    }

    function updateSessionStats() {
        const total = sessionCorrectCount + sessionWrongCount;
        DOM.sessionCorrect.textContent = sessionCorrectCount;
        DOM.sessionWrong.textContent = sessionWrongCount;
        DOM.sessionAccuracy.textContent = total > 0 ? Math.round(sessionCorrectCount / total * 100) + '%' : '0%';
    }

    function handleInputComplete(isCorrect, userInput) {
        const stat = getCharStat(currentCharacter);
        const now = Date.now();
        stat.lastPracticed = now;
        
        if (isCorrect) {
            stat.successCount++;
            sessionCorrectCount++;
            updateSessionStats();
            // SM-2 style interval calculation
            if (stat.interval < 1) stat.interval = 1;
            else if (stat.interval === 1) stat.interval = 6;
            else stat.interval = Math.round(stat.interval * 2.5);
            
            // Cap at 30 days
            stat.interval = Math.min(stat.interval, 30 * 24 * 60);
        } else {
            stat.failCount++;
            stat.interval = 1;
            sessionWrongCount++;
            updateSessionStats();
            flashFeedback(false);
            
            // Add to session mistake queue for review
            if (!sessionMistakeQueue.includes(currentCharacter)) {
                sessionMistakeQueue.push(currentCharacter);
            }
            
            // Show hint
            const codes = dictionary[currentCharacter];
            DOM.hintDisplay.textContent = `${currentCharacter} ‚Üí ${codes ? codes.join(' / ') : '?'}`;
            DOM.hintDisplay.classList.add('status-error');
        }
        
        stat.nextReview = now + stat.interval * 60000;
        saveCurrentProfileProgress();
        
        setTimeout(() => {
            DOM.hintDisplay.textContent = '';
            DOM.hintDisplay.classList.remove('status-error');
            nextCharacter();
        }, isCorrect ? 100 : 800);
    }
    
    function showStatusMessage(msg, options = {}) {
        DOM.hintDisplay.textContent = msg;
        DOM.hintDisplay.classList.remove('status-success', 'status-error');
        if (options.isError) DOM.hintDisplay.classList.add('status-error');
        else if (options.isSuccess) DOM.hintDisplay.classList.add('status-success');
        
        if (!options.persistent) {
            setTimeout(() => {
                DOM.hintDisplay.textContent = '';
                DOM.hintDisplay.classList.remove('status-success', 'status-error');
            }, options.duration || 2000);
        }
    }

    async function fetchRemoteDict(urls) {
        DOM.startPracticeBtn.disabled = true;
        showStatusMessage('Ê≠£Âú®Âä†ËΩΩËøúÁ®ãÁ†ÅË°®...', { persistent: true });
        try {
            const responses = await Promise.all(urls.map(url => fetch(url)));
            const allContents = await Promise.all(responses.map(r => r.text()));
            allContents.forEach(contents => parseAndMergeDict(contents));
            showStatusMessage(`Á†ÅË°®Âä†ËΩΩÂÆåÊàê (${Object.keys(dictionary).length}Â≠ó)`, { isSuccess: true });
        } catch (error) {
            showStatusMessage(`Á†ÅË°®Âä†ËΩΩÂ§±Ë¥•: ${error.message}`, { isError: true });
        } finally {
            DOM.startPracticeBtn.disabled = false;
        }
    }

    function saveAllProfiles() {
        const profiles = JSON.parse(localStorage.getItem('codeGlyphProfiles') || '{}');
        profiles[currentProfileId] = currentProfile;
        localStorage.setItem('codeGlyphProfiles', JSON.stringify(profiles));
    }

    function saveCurrentProfileProgress() {
        saveAllProfiles();
    }

    function loadCurrentProfileProgress() {
        const profiles = JSON.parse(localStorage.getItem('codeGlyphProfiles') || '{}');
        currentProfile = profiles[currentProfileId] || {};
        
        // Migrate old format if needed
        migrateOldProfile();
    }

    function migrateOldProfile() {
        // Check if migration is needed (old format had different structure)
        for (const char in currentProfile) {
            const stat = currentProfile[char];
            if (typeof stat === 'object' && stat !== null) {
                // Ensure all required fields exist
                if (stat.successCount === undefined) stat.successCount = 0;
                if (stat.failCount === undefined) stat.failCount = 0;
                if (stat.lastPracticed === undefined) stat.lastPracticed = 0;
                if (stat.interval === undefined) stat.interval = 1;
                if (stat.nextReview === undefined) stat.nextReview = 0;
            }
        }
        saveAllProfiles();
    }

    function updateStats() {
        const text = DOM.practiceTextInput.value;
        const uniqueChars = [...new Set(text.replace(/\s/g, ''))].filter(c => /[\u4e00-\u9fff]/.test(c));
        DOM.totalCharsSpan.textContent = uniqueChars.length;
        
        const pendingCount = uniqueChars.filter(char => {
            const stat = currentProfile[char];
            return !stat || stat.successCount === 0;
        }).length;
        DOM.pendingCharsSpan.textContent = pendingCount;
    }

    function updateUIForSelection() {
        const textSelection = DOM.textSelect.value;
        if (textSelection === 'custom') {
            DOM.customTextControls.style.display = 'block';
            DOM.practiceTextInput.value = '';
        } else {
            DOM.customTextControls.style.display = 'none';
            DOM.practiceTextInput.value = PREDEFINED_TEXTS[textSelection] || '';
        }
    }

    async function handleDictSelection() {
        currentProfileId = DOM.dictSelect.value;
        localStorage.setItem('lastDictSelection', currentProfileId);
        loadCurrentProfileProgress();
        
        const selection = DOM.dictSelect.value;
        if (selection === 'custom') {
            // Load custom dict from localStorage
            const savedContent = localStorage.getItem('customDictContent');
            if (savedContent) {
                try {
                    dictionary = {};
                    const allContents = JSON.parse(savedContent);
                    allContents.forEach(contents => parseAndMergeDict(contents));
                    const displayName = customDictName || 'Ëá™ÂÆö‰πâÁ†ÅË°®';
                    showStatusMessage(`${displayName} Âä†ËΩΩÂÆåÊàê (${Object.keys(dictionary).length}Â≠ó)`);
                } catch (e) {
                    showStatusMessage('Ëá™ÂÆö‰πâÁ†ÅË°®Âä†ËΩΩÂ§±Ë¥•ÔºåËØ∑ÈáçÊñ∞‰∏ä‰º†', { isError: true });
                }
            } else {
                showStatusMessage('ËØ∑ÂÖà‰∏ä‰º†Á†ÅË°®Êñá‰ª∂', { isError: true });
            }
        } else if (PREDEFINED_DICTS[selection]) {
            dictionary = {};
            await fetchRemoteDict(PREDEFINED_DICTS[selection]);
        }
        updateStats();
    }

    function startPracticeSession() {
        const text = DOM.practiceTextInput.value;
        practiceSet = [...new Set(text.replace(/\s/g, ''))].filter(c => /[\u4e00-\u9fff]/.test(c) && dictionary[c]);
        
        if (practiceSet.length === 0) {
            showStatusMessage('Ê≤°ÊúâÂèØÁªÉ‰π†ÁöÑÂ≠óÁ¨¶ÔºåËØ∑Ê£ÄÊü•ÊñáÊú¨ÂíåÁ†ÅË°®', { isError: true });
            return;
        }
        
        sessionMistakeQueue = [];
        sessionCorrectCount = 0;
        sessionWrongCount = 0;
        
        // Hide setup, show practice (keep stats visible)
        document.querySelectorAll('.setup-section').forEach(el => el.style.display = 'none');
        DOM.sessionStats.style.display = 'block';
        updateSessionStats();
        DOM.inputArea.style.display = 'block';
        DOM.exitPracticeBtn.style.display = 'block';
        
        nextCharacter();
        DOM.typingInput.focus();
    }

    function nextCharacter() {
        currentCharacter = getNextChar();
        DOM.characterDisplay.textContent = currentCharacter;
        DOM.characterDisplay.classList.remove('app-title');
        DOM.typingInput.value = '';
        DOM.typingInput.focus();
    }

    function exitPractice() {
        // Show setup, hide practice
        document.querySelectorAll('.setup-section').forEach(el => el.style.display = 'flex');
        const gridSection = document.querySelector('.setup-section[style*="grid"]');
        if (gridSection) gridSection.style.display = 'grid';
        document.getElementById('stats').style.display = 'block';
        DOM.sessionStats.style.display = 'none';
        DOM.inputArea.style.display = 'none';
        DOM.exitPracticeBtn.style.display = 'none';
        DOM.characterDisplay.textContent = 'Á†Å‰∏äÁîüËä±';
        DOM.characterDisplay.classList.add('app-title');
        DOM.hintDisplay.textContent = '';
        updateStats();
    }

    function clearProgress() {
        const profileName = DOM.dictSelect.options[DOM.dictSelect.selectedIndex].text;
        if (confirm(`Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫„Äå${profileName}„ÄçÁöÑÊâÄÊúâÁªÉ‰π†ËøõÂ∫¶ÂêóÔºüÊ≠§Êìç‰Ωú‰∏çÂèØÊÅ¢Â§ç„ÄÇ`)) {
            currentProfile = {};
            saveCurrentProfileProgress();
            showStatusMessage('ËøõÂ∫¶Â∑≤Ê∏ÖÁ©∫', { isSuccess: true });
            updateStats();
        }
    }

    DOM.textSelect.addEventListener('change', () => {
        localStorage.setItem('lastTextSelection', DOM.textSelect.value);
        updateUIForSelection();
        updateStats();
    });
    DOM.practiceTextInput.addEventListener('input', updateStats);

    // Extract name from YAML header (between --- and ...)
    function extractDictName(contents) {
        const lines = contents.split('\n');
        let inHeader = false;
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed === '---') { inHeader = true; continue; }
            if (trimmed === '...') break;
            if (!inHeader) continue;
            const match = trimmed.match(/^name:\s*["']?(.+?)["']?\s*$/);
            if (match) return match[1];
        }
        return null;
    }

    function ensureCustomDictOption(name) {
        const displayName = name || customDictName || 'Ëá™ÂÆö‰πâ';
        let option = DOM.dictSelect.querySelector('option[value="custom"]');
        if (!option) {
            option = document.createElement('option');
            option.value = 'custom';
            DOM.dictSelect.appendChild(option);
        }
        option.textContent = displayName;
    }

    DOM.dictUpload.addEventListener('change', async (event) => {
        const files = event.target.files; if (!files.length) return;

        // Set profile to custom and load progress
        currentProfileId = 'custom';
        localStorage.setItem('lastDictSelection', 'custom');
        loadCurrentProfileProgress();

        DOM.startPracticeBtn.disabled = true;
        try {
            const readFile = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
            const allContents = await Promise.all(Array.from(files).map(readFile));
            dictionary = {}; // Clear the dictionary cleanly before parsing
            
            // Extract names from all files and join with "+"
            const names = allContents
                .map(contents => extractDictName(contents))
                .filter(name => name);
            customDictName = names.join('+');
            // Save name and content to localStorage for persistence
            localStorage.setItem('customDictName', customDictName);
            localStorage.setItem('customDictContent', JSON.stringify(allContents));
            
            allContents.forEach(contents => parseAndMergeDict(contents));
            
            // Add custom option with name and select it
            ensureCustomDictOption(customDictName);
            DOM.dictSelect.value = 'custom';
            
            const displayName = customDictName || 'Ëá™ÂÆö‰πâÁ†ÅË°®';
            showStatusMessage(`${displayName} Âä†ËΩΩÂÆåÊàê (${Object.keys(dictionary).length}Â≠ó)`);
        } catch(error) {
            showStatusMessage(`Á†ÅË°®ËØªÂèñÂ§±Ë¥•: ${error.message}`, { isError: true });
            dictionary = {}; // Ensure dictionary is empty on failure
        } finally {
            DOM.startPracticeBtn.disabled = false;
            updateStats();
        }
    });

    function parseAndMergeDict(contents){const lines=contents.split("\n");let dataSection=!1;for(const line of lines){if("---"===line.trim()){dataSection=!0;continue}if(!dataSection)continue;const trimmedLine=line.trim();if(!trimmedLine||trimmedLine.startsWith("#"))continue;const parts=trimmedLine.split("\t");if(parts.length<2)continue;const char=parts[0],code=parts[1];if(char&&code&&1===char.trim().length){dictionary[char]||(dictionary[char]=[]),dictionary[char].includes(code)||dictionary[char].push(code)}}}
    function flashFeedback(isCorrect){DOM.typingInput.style.borderColor=isCorrect?"var(--success-color)":"var(--danger-color)",isCorrect||DOM.typingInput.classList.add("shake"),setTimeout(()=>{DOM.typingInput.style.borderColor="var(--medium-gray-color)",isCorrect||DOM.typingInput.classList.remove("shake")},500)}
    
    DOM.typingInput.addEventListener("input", (e) => {
        if (!currentCharacter) return;
        const userInput = e.target.value;
        const correctCodes = dictionary[currentCharacter];
        if (!correctCodes) return;

        if (correctCodes.every(code => !code.startsWith(userInput))) {
            return handleInputComplete(false, userInput);
        }
        
        if (correctCodes.includes(userInput)) {
            flashFeedback(true);
            handleInputComplete(true, userInput);
        }
    });

    function exportProgress() {
        const profiles = JSON.parse(localStorage.getItem('codeGlyphProfiles') || '{}');
        const data = {
            version: 1,
            exportDate: new Date().toISOString(),
            profiles: profiles
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `codeglyph-progress-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatusMessage('ËøõÂ∫¶Â∑≤ÂØºÂá∫', { isSuccess: true });
    }

    function importProgress(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (data.profiles) {
                    localStorage.setItem('codeGlyphProfiles', JSON.stringify(data.profiles));
                    loadCurrentProfileProgress();
                    updateStats();
                    showStatusMessage('ËøõÂ∫¶Â∑≤ÂØºÂÖ•', { isSuccess: true });
                } else {
                    throw new Error('Invalid format');
                }
            } catch (error) {
                showStatusMessage('ÂØºÂÖ•Â§±Ë¥•: Êó†ÊïàÁöÑÊñá‰ª∂Ê†ºÂºè', { isError: true });
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset input
    }

    DOM.startPracticeBtn.addEventListener('click', startPracticeSession);
    DOM.exitPracticeBtn.addEventListener('click', exitPractice);
    DOM.clearProgressBtn.addEventListener('click', clearProgress);
    DOM.exportProgressBtn.addEventListener('click', exportProgress);
    DOM.dictSelect.addEventListener('change', handleDictSelection);
    DOM.importProgressBtn.addEventListener('click', () => DOM.importFileInput.click());
    DOM.importFileInput.addEventListener('change', importProgress);
    DOM.uploadDictBtn.addEventListener('click', () => DOM.dictUpload.click());
    
    // Theme toggle
    function toggleTheme() {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        if (isDark) {
            document.documentElement.removeAttribute('data-theme');
            DOM.themeToggle.textContent = '‚òÄÔ∏è';
            localStorage.setItem('theme', 'light');
        } else {
            document.documentElement.setAttribute('data-theme', 'dark');
            DOM.themeToggle.textContent = 'üåô';
            localStorage.setItem('theme', 'dark');
        }
    }
    DOM.themeToggle.addEventListener('click', toggleTheme);
    
    // Initialize theme
    if (localStorage.getItem('theme') === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
        DOM.themeToggle.textContent = 'üåô';
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Esc to exit practice
        if (e.key === 'Escape' && DOM.inputArea.style.display !== 'none') {
            exitPractice();
        }
    });
    
    function initializeApp() {
        const lastDict = localStorage.getItem('lastDictSelection') || 'feidan';
        const lastText = localStorage.getItem('lastTextSelection') || 'custom';
        
        // Restore custom dict name from localStorage
        customDictName = localStorage.getItem('customDictName') || '';
        const hasCustomDict = localStorage.getItem('customDictContent');
        
        // If user has uploaded a custom dict before, add the option
        if (hasCustomDict) {
            ensureCustomDictOption(customDictName);
        }
        
        // Select the appropriate dict
        if (lastDict === 'custom' && hasCustomDict) {
            DOM.dictSelect.value = 'custom';
            handleDictSelection();
        } else if (PREDEFINED_DICTS[lastDict]) {
            DOM.dictSelect.value = lastDict;
            handleDictSelection();
        } else {
            DOM.dictSelect.value = 'feidan';
            handleDictSelection();
        }
        DOM.textSelect.value = lastText;
        
        updateUIForSelection();
        console.log('CodeGlyph Adaptive. Ready.');
    }

    initializeApp();
  </script>
</body>
</html>
