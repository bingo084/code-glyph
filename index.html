<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeGlyph - 码上生花</title>
    <style>
        :root {
            --primary-color: #007aff;
            --primary-hover-color: #0056b3;
            --danger-color: #dc3545;
            --danger-hover-color: #c82333;
            --light-gray-color: #f8f9fa;
            --medium-gray-color: #dee2e6;
            --dark-gray-color: #6c757d;
            --dark-gray-hover-color: #5a6268;
            --text-color: #212529;
            --text-muted-color: #666;
            --bg-color: #fff;
            --border-light-color: #eee;
            --disabled-color: #aaa;
            --success-color: #28a745;
            --border-radius: 8px;
        }
        [data-theme="dark"] {
            --primary-color: #4da3ff;
            --primary-hover-color: #7ab8ff;
            --danger-color: #ff6b7a;
            --danger-hover-color: #ff8a96;
            --light-gray-color: #1e1e1e;
            --medium-gray-color: #3a3a3a;
            --dark-gray-color: #a0a0a0;
            --dark-gray-hover-color: #b0b0b0;
            --text-color: #e0e0e0;
            --text-muted-color: #999;
            --bg-color: #2a2a2a;
            --border-light-color: #444;
            --disabled-color: #555;
            --success-color: #4ade80;
        }
        [data-theme="dark"] select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23a0a0a0' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
        }
        [data-theme="dark"] input[type="text"],
        [data-theme="dark"] textarea,
        [data-theme="dark"] select {
            color: var(--text-color);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 5vh;
            margin: 0;
            background-color: var(--light-gray-color);
            color: var(--text-color);
        }
        .container {
            position: relative;
            text-align: center;
            padding: 20px 25px;
            border-radius: var(--border-radius);
            background-color: var(--bg-color);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            width: 90%;
            max-width: 420px;
        }
        h1 {
            font-size: 4.5rem;
            margin: 15px 0 0 0;
            color: var(--text-color);
            min-height: 70px;
            font-weight: 600;
        }
        .app-title {
            font-size: 1.8rem;
            min-height: auto;
            color: var(--primary-color);
            letter-spacing: 2px;
        }
        #hint-display {
            font-size: 1.1rem;
            color: var(--dark-gray-color);
            margin-top: 5px;
            min-height: 1.5em;
            transition: all 0.3s;
        }
        #stats {
            margin-top: 15px;
        }
        #stats p {
            font-size: 0.9rem;
            margin: 0;
        }
        .status-success { color: var(--success-color) !important; }
        .status-error { color: var(--danger-color) !important; }
        #typing-input {
            font-family: 'SF Mono', 'Menlo', 'Monaco', monospace;
            letter-spacing: 2px;
            text-align: center;
            font-size: 1.4rem;
        }
        input[type="text"], textarea, select {
            display: block;
            box-sizing: border-box;
            margin: 10px auto;
            width: 100%;
            font-size: 0.9rem;
            padding: 8px 10px;
            border: 1px solid var(--medium-gray-color);
            border-radius: var(--border-radius);
            transition: border-color 0.2s, box-shadow 0.2s;
            background-color: var(--light-gray-color);
        }
        input[type="text"]:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25);
        }
        .setup-section {
            display: flex; flex-direction: column;
            gap: 12px; align-items: center; margin-top: 15px;
        }
        .setup-row {
            display: flex; align-items: center;
            justify-content: flex-start; gap: 15px;
            width: 100%;
        }
        .setup-row label {
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
        }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 16px 12px;
            flex-grow: 1;
        }
        button {
            width: 100%;
            font-size: 0.9rem;
            font-weight: 500;
            padding: 8px 10px;
            border-radius: var(--border-radius);
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:disabled { background-color: var(--disabled-color); cursor: not-allowed; transform: none; box-shadow: none; border-color: transparent; color: var(--text-color); }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--primary-hover-color);
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: var(--dark-gray-color);
            color: white;
        }
        .btn-secondary:hover {
            background-color: var(--dark-gray-hover-color);
            transform: translateY(-1px);
        }
        #clear-progress-btn {
            width: auto;
            padding: 6px 12px;
            font-size: 0.8rem;
            background-color: var(--light-gray-color);
            color: var(--dark-gray-color);
            border-color: var(--medium-gray-color);
        }
        #clear-progress-btn:hover {
            background-color: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
            transform: translateY(-1px);
        }
        #exit-practice-btn {
            position: absolute; top: 15px; left: 15px;
            width: auto; padding: 5px 12px;
            font-size: 0.9rem; font-weight: 500;
            background-color: transparent; border: none;
            color: var(--dark-gray-color);
        }
        #exit-practice-btn:hover { background-color: var(--light-gray-color); transform: none; }
        .setup-section[style*="grid"] {
            margin-top: 12px;
            gap: 8px;
        }
        #dict-upload {
            display: none;
        }
        .icon-btn {
            width: 36px;
            height: 36px;
            min-width: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--light-gray-color);
            border: 1px solid var(--medium-gray-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s;
        }
        .icon-btn:hover {
            background-color: var(--medium-gray-color);
            transform: translateY(-1px);
        }
        .icon-btn svg {
            width: 18px;
            height: 18px;
            stroke: var(--dark-gray-color);
        }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } }
        .shake { animation: shake 0.5s ease-in-out; }
        #theme-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            padding: 4px;
            border: none;
            background: transparent;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        #theme-toggle:hover {
            opacity: 1;
            transform: none;
        }
        #theme-toggle svg {
            width: 100%;
            height: 100%;
            stroke: var(--text-color);
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        #theme-toggle .icon-moon { display: none; }
        [data-theme="dark"] #theme-toggle .icon-sun { display: none; }
        [data-theme="dark"] #theme-toggle .icon-moon { display: block; }
    </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle" title="切换深色模式">
      <svg class="icon-sun" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
      <svg class="icon-moon" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
    </button>
    <button id="exit-practice-btn" style="display: none;">← 返回</button>
    <div id="character-display"><h1 class="app-title">码上生花</h1></div>
    <div id="hint-display"></div>
    <div id="input-area" style="display: none;">
      <input type="text" id="typing-input" placeholder="在此输入编码" autofocus>
    </div>

    <div class="setup-section">
      <div class="setup-row">
        <label for="dict-select">码表:</label>
        <select id="dict-select">
          <option value="feidan">飞单</option>
        </select>
        <button id="upload-dict-btn" class="icon-btn" title="上传自定义码表">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
        </button>
        <input type="file" id="dict-upload" accept=".yaml,.txt" multiple>
      </div>
      <div class="setup-row">
        <label for="text-select">文本:</label>
        <select id="text-select">
            <option value="custom">自定义粘贴</option>
            <option value="top500">常用前500字</option>
            <option value="mid500">常用中500字</option>
            <option value="last500">常用后500字</option>
            <option value="top1000">常用前1000字</option>
            <option value="top1500">常用前1500字</option>
        </select>
      </div>
      <div id="custom-text-controls" style="width: 100%;">
        <textarea id="practice-text-input" placeholder="请在此处粘贴或选择预设文本..."></textarea>
      </div>
      <button id="start-practice-btn" class="btn-primary">开始练习</button>
    </div>

    <div id="stats" style="margin-top: 20px; color: var(--text-muted-color);">
      <p>总字数: <span id="total-chars">0</span> | 待练习: <span id="pending-chars">0</span></p>
    </div>
    <div id="session-stats" style="display: none; margin-top: 15px; color: var(--text-muted-color);">
      <p>正确: <span id="session-correct" style="color: var(--success-color);">0</span> | 错误: <span id="session-wrong" style="color: var(--danger-color);">0</span> | 正确率: <span id="session-accuracy">0%</span></p>
    </div>
    <div class="setup-section" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-light-color); width: 100%; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <button id="import-progress-btn" class="btn-secondary">导入进度</button>
        <button id="export-progress-btn" class="btn-secondary">导出进度</button>
        <input type="file" id="import-file-input" accept=".json" style="display: none;">
    </div>
    <div style="margin-top: 10px; text-align: center;">
        <button id="clear-progress-btn">清空进度</button>
    </div>
  </div>

  <script>
    const DOM = {
      characterDisplay: document.getElementById('character-display').querySelector('h1'),
      hintDisplay: document.getElementById('hint-display'),
      typingInput: document.getElementById('typing-input'),
      dictSelect: document.getElementById('dict-select'),
      textSelect: document.getElementById('text-select'),
      dictUpload: document.getElementById('dict-upload'),
      uploadDictBtn: document.getElementById('upload-dict-btn'),
      practiceTextInput: document.getElementById('practice-text-input'),
      startPracticeBtn: document.getElementById('start-practice-btn'),
      totalCharsSpan: document.getElementById('total-chars'),
      pendingCharsSpan: document.getElementById('pending-chars'),
      customTextControls: document.getElementById('custom-text-controls'),
      setupSection: document.querySelector('.setup-section'),
      inputArea: document.getElementById('input-area'),
      clearProgressBtn: document.getElementById('clear-progress-btn'),
      exitPracticeBtn: document.getElementById('exit-practice-btn'),
      importProgressBtn: document.getElementById('import-progress-btn'),
      exportProgressBtn: document.getElementById('export-progress-btn'),
      importFileInput: document.getElementById('import-file-input'),
      sessionStats: document.getElementById('session-stats'),
      sessionCorrect: document.getElementById('session-correct'),
      sessionWrong: document.getElementById('session-wrong'),
      sessionAccuracy: document.getElementById('session-accuracy'),
      themeToggle: document.getElementById('theme-toggle'),
    };

    const PREDEFINED_TEXTS = {
      top500: '的一是了不在有个人这上中大为来我到出要以时和地们得可下对生也子就过能他会多发说而于自之用年行家方后作成开面事好小心前所道法如进着同经分定都然与本还其当起动已两点从问里主实天高去现长此三将无国全文理明日些看只公等十意正外想间把情者没重相那向知因样学应又手但信关使种见力名二处门并口么先位头回话很再由身入内第平被给次别几月真立新通少机打水果最部何安接报声才体今合性西你放表目加常做己老四件解路更走比总金管光工结提任东原便美及教难世至气神山数利书代直色场变记张必受交非服化求风度太万各算边王什快许连五活思该步海指物则女或完马强言条特命感清带认保望转传儿制干计民白住字它义车像反象题却流且即深近形取往系量论告息让决未花收满每华业南觉电空眼听远师元请容她军士百办语期北林识半夫客战院城候单音台死视领失司亲始极双令改功程爱德复切随李员离轻观青足落叫根怎持精送众影八首包准兴红达早尽故房引火站似找备调断设格消拉照布友整术石展紧据终周式举飞片虽易运笑云建谈界务写钱商乐推注越千微若约英集示呢待坐议乎留称品志黑存六造低江念产刻节尔吃势依图共曾响底装具喜严九况跟罗须显热病证刚治绝群市阳确究久除闻答段官政类黄武七支费父统',
      mid500: '府查般斯倒突号树拿克初广奇愿欢希母香破谁致线急古既句京甚仍晚争游龙余护另器细木权星哪苦孩试朝阿队居害独讲错局男差参社换选止际假汉够诉资密案史较环投静宝专修室区料帮衣竟模脸善兵考规联团冷玉施派纪采历顾春责夜画惊银负续吗简章左块索酒值态按陈河巴冲阵境助角户乱呼灵脚继楼景怕停铁异谢否伤蘭置医良承福科属围需退基右速适药怀击买素背岁土忙充排价质遇端列印贵疑露哥杀标招血礼弟亮齐穿脑委州某顺省讨尚维板散项状追笔副层沙养读习永草胡济执察归富座雨堂威忽苏船罪敢妇村著食导免温莫掌激慢托胜险寻守波雷沉秀职验靠楚略族藏丽渐刘仅肯担扬盘唐钟级毛营坚松皮供店饭范哈赶吧雪斗效临农味恶烟园烈配杂短卫跳孙曲封抓移顿律卖艺旧朋救防脱翻划迎痛校窗宣乡杨叶警限湖软掉财词压挥超屋秋跑忘馆暗班党宗坏技困登姐预耳席梦朱组旁份禁套亚益探康增诗戏伯晓含劳恩顶君庄谓付田毕纸研虚怪宁替犯灯优您姓例丝盖误架幸隐股毒娘占智佛床米凡介征彩演射祖欲束获舞圣伙梅普借私源镇睡缓升纳织歌宫概野醒夏互积街牌休摇洋败监骨批兄刀网率庭熟创访硬仁菜丁绿牛避阴拍雄秘缺卷姑尼油恐玩释遍握球降虑荣策肉妈迷检伸欧攻练育危厅啊睛摆茶勇判材抱亦妻吸喝趣嘴逐操午吉浪轮默毫冰',
      last500: '珠鼓阶孔徐固偏陆诸遗爷述帝闭补编巨透弄尤鲁拥录吴墙货弱敌挑宽迹抽忍折输稳皇桌献蒙纷麻洗评挂童尊舍唯博剧乃混弹附迟敬杯鱼控塞剑厚佳测训牙洞淡盛县芳雅革款横累择乘刺载猛逃构赵杜庆途奔虎巧抗针徒圆闪谷绍聚额健诚鲜泪闲均序震仿缘戴婚篇亡奶忠烦赛闹协杰残懂丹柳妹映桥叹愈旅授享暴偷蓝氏寒宜弃丰延辈抢颜赞典冒眉烧厂唱径库川辞伴怒型纯贝票隔穷拜审伦悲柔启减页纵扫伟迫振瑞丈梁洲枪央触予孤缩洛损促番罢宋奋销幕犹锁珍抬陪妙摸峰劲镜沈夺昨哭讯貌谋泰侧贫扶阻贴申岸彼赏版抵泽插迅凭伊潮咱仙符宇肩尝递燕洁拒郎凝净遭仪薄卡末勒乌森诺呀壮忧沿惯丢季企壁惜婆袋朗零辛忆努舒枝凤灭韩胆灰旦孟陷俗绕疾瞧洪甲帐糊泛皆碰吹码奉箱倾胸堆狂仲圈冬餐厉腿尖括佩鬼欣垂跃港骗融撞塔紫荡敏郑赖滑允鸟课暂瓦祥染滚浮粗刑辆狗扑稍秦扎魂岛腾臣琴悉络摩措域冠竹殊豪呆萨旋喊寄悄倍祝剩督旗返召彻宾甘吐乔腰拔幅违详臂尺饮颗涉逼竞培惠亏叔伏唤鸡邻池怨奥侯骑漫拖俊尾恨贯凌兼询碎晨罚铺浓伍宿泉井繁粉绪筑恢匹尘辉魔仰董描距盗渡勤劝莲坦搭挺踪幽截荒恰慧邦颇焦醉废掩签丧灾鼻侵陶肃裁俱磨析奖匆瓶泥拾凉麦钢涌潜隆津搞蛋奈扰耐傅锦播墨偶捕惑飘屈鸣挤毁斜啦污赤慰饰锋覆汤寿跨羊'
    };
    PREDEFINED_TEXTS.top1000 = (PREDEFINED_TEXTS.top500 || '') + (PREDEFINED_TEXTS.mid500 || '');
    PREDEFINED_TEXTS.top1500 = (PREDEFINED_TEXTS.top500 || '') + (PREDEFINED_TEXTS.mid500 || '') + (PREDEFINED_TEXTS.last500 || '');

    const PREDEFINED_DICTS = {feidan: ['https://raw.githubusercontent.com/sbsrf/sbsrf/refs/heads/main/sbxlm/sbfd.dict.yaml', 'https://raw.githubusercontent.com/sbsrf/sbsrf/refs/heads/main/sbxlm/sbf.dict.yaml']};

    let dictionary = {}, practiceSet = [];
    let currentCharacter = null;
    let currentProfile = {};
    let currentProfileId = 'feidan';
    let sessionMistakeQueue = [];
    let customDictName = '';
    let sessionCorrectCount = 0;
    let sessionWrongCount = 0;

    function getCharStat(char) {
        if (!currentProfile[char]) {
            currentProfile[char] = { successCount: 0, failCount: 0, lastPracticed: 0, interval: 1, nextReview: 0 };
        }
        return currentProfile[char];
    }

    function getNextChar() {
        const now = Date.now();
        
        // Priority 1: Review mistakes from current session
        if (sessionMistakeQueue.length > 0 && Math.random() < 0.6) {
            const char = sessionMistakeQueue.shift();
            if (practiceSet.includes(char)) return char;
        }
        
        // Priority 2: Characters due for review (sorted by urgency)
        const dueChars = practiceSet
            .filter(char => getCharStat(char).nextReview <= now && getCharStat(char).successCount > 0)
            .sort((a, b) => getCharStat(a).nextReview - getCharStat(b).nextReview);
        
        if (dueChars.length > 0 && Math.random() < 0.7) {
            return dueChars[0];
        }
        
        // Priority 3: New characters (never practiced)
        const newChars = practiceSet.filter(char => getCharStat(char).successCount === 0 && getCharStat(char).failCount === 0);
        if (newChars.length > 0 && Math.random() < 0.5) {
            return newChars[Math.floor(Math.random() * Math.min(5, newChars.length))];
        }
        
        // Priority 4: Weighted random selection
        const weights = practiceSet.map(char => {
            const stat = getCharStat(char);
            const timeSinceReview = now - stat.lastPracticed;
            const failWeight = 1 + stat.failCount * 2;
            const timeWeight = Math.min(3, timeSinceReview / (stat.interval * 60000 * 0.5));
            return Math.max(0.1, failWeight * timeWeight);
        });
        
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let random = Math.random() * totalWeight;
        
        for (let i = 0; i < practiceSet.length; i++) {
            random -= weights[i];
            if (random <= 0) return practiceSet[i];
        }
        
        return practiceSet[Math.floor(Math.random() * practiceSet.length)];
    }

    function updateSessionStats() {
        const total = sessionCorrectCount + sessionWrongCount;
        DOM.sessionCorrect.textContent = sessionCorrectCount;
        DOM.sessionWrong.textContent = sessionWrongCount;
        DOM.sessionAccuracy.textContent = total > 0 ? Math.round(sessionCorrectCount / total * 100) + '%' : '0%';
    }

    function handleInputComplete(isCorrect, userInput) {
        const stat = getCharStat(currentCharacter);
        const now = Date.now();
        stat.lastPracticed = now;
        
        if (isCorrect) {
            stat.successCount++;
            sessionCorrectCount++;
            updateSessionStats();
            // SM-2 style interval calculation
            if (stat.interval < 1) stat.interval = 1;
            else if (stat.interval === 1) stat.interval = 6;
            else stat.interval = Math.round(stat.interval * 2.5);
            
            // Cap at 30 days
            stat.interval = Math.min(stat.interval, 30 * 24 * 60);
        } else {
            stat.failCount++;
            stat.interval = 1;
            sessionWrongCount++;
            updateSessionStats();
            flashFeedback(false);
            
            // Add to session mistake queue for review
            if (!sessionMistakeQueue.includes(currentCharacter)) {
                sessionMistakeQueue.push(currentCharacter);
            }
            
            // Show hint
            const codes = dictionary[currentCharacter];
            DOM.hintDisplay.textContent = `${currentCharacter} → ${codes ? codes.join(' / ') : '?'}`;
            DOM.hintDisplay.classList.add('status-error');
        }
        
        stat.nextReview = now + stat.interval * 60000;
        saveCurrentProfileProgress();
        
        setTimeout(() => {
            DOM.hintDisplay.textContent = '';
            DOM.hintDisplay.classList.remove('status-error');
            nextCharacter();
        }, isCorrect ? 100 : 800);
    }
    
    function showStatusMessage(msg, options = {}) {
        DOM.hintDisplay.textContent = msg;
        DOM.hintDisplay.classList.remove('status-success', 'status-error');
        if (options.isError) DOM.hintDisplay.classList.add('status-error');
        else if (options.isSuccess) DOM.hintDisplay.classList.add('status-success');
        
        if (!options.persistent) {
            setTimeout(() => {
                DOM.hintDisplay.textContent = '';
                DOM.hintDisplay.classList.remove('status-success', 'status-error');
            }, options.duration || 2000);
        }
    }

    async function fetchRemoteDict(urls) {
        DOM.startPracticeBtn.disabled = true;
        showStatusMessage('正在加载远程码表...', { persistent: true });
        try {
            const responses = await Promise.all(urls.map(url => fetch(url)));
            const allContents = await Promise.all(responses.map(r => r.text()));
            allContents.forEach(contents => parseAndMergeDict(contents));
            showStatusMessage(`码表加载完成 (${Object.keys(dictionary).length}字)`, { isSuccess: true });
        } catch (error) {
            showStatusMessage(`码表加载失败: ${error.message}`, { isError: true });
        } finally {
            DOM.startPracticeBtn.disabled = false;
        }
    }

    function saveAllProfiles() {
        const profiles = JSON.parse(localStorage.getItem('codeGlyphProfiles') || '{}');
        profiles[currentProfileId] = currentProfile;
        localStorage.setItem('codeGlyphProfiles', JSON.stringify(profiles));
    }

    function saveCurrentProfileProgress() {
        saveAllProfiles();
    }

    function loadCurrentProfileProgress() {
        const profiles = JSON.parse(localStorage.getItem('codeGlyphProfiles') || '{}');
        currentProfile = profiles[currentProfileId] || {};
        
        // Migrate old format if needed
        migrateOldProfile();
    }

    function migrateOldProfile() {
        // Check if migration is needed (old format had different structure)
        for (const char in currentProfile) {
            const stat = currentProfile[char];
            if (typeof stat === 'object' && stat !== null) {
                // Ensure all required fields exist
                if (stat.successCount === undefined) stat.successCount = 0;
                if (stat.failCount === undefined) stat.failCount = 0;
                if (stat.lastPracticed === undefined) stat.lastPracticed = 0;
                if (stat.interval === undefined) stat.interval = 1;
                if (stat.nextReview === undefined) stat.nextReview = 0;
            }
        }
        saveAllProfiles();
    }

    function updateStats() {
        const text = DOM.practiceTextInput.value;
        const uniqueChars = [...new Set(text.replace(/\s/g, ''))].filter(c => /[\u4e00-\u9fff]/.test(c));
        DOM.totalCharsSpan.textContent = uniqueChars.length;
        
        const pendingCount = uniqueChars.filter(char => {
            const stat = currentProfile[char];
            return !stat || stat.successCount === 0;
        }).length;
        DOM.pendingCharsSpan.textContent = pendingCount;
    }

    function updateUIForSelection() {
        const textSelection = DOM.textSelect.value;
        if (textSelection === 'custom') {
            DOM.customTextControls.style.display = 'block';
            DOM.practiceTextInput.value = '';
        } else {
            DOM.customTextControls.style.display = 'none';
            DOM.practiceTextInput.value = PREDEFINED_TEXTS[textSelection] || '';
        }
    }

    async function handleDictSelection() {
        currentProfileId = DOM.dictSelect.value;
        localStorage.setItem('lastDictSelection', currentProfileId);
        loadCurrentProfileProgress();
        
        const selection = DOM.dictSelect.value;
        if (selection === 'custom') {
            // Load custom dict from localStorage
            const savedContent = localStorage.getItem('customDictContent');
            if (savedContent) {
                try {
                    dictionary = {};
                    const allContents = JSON.parse(savedContent);
                    allContents.forEach(contents => parseAndMergeDict(contents));
                    const displayName = customDictName || '自定义码表';
                    showStatusMessage(`${displayName} 加载完成 (${Object.keys(dictionary).length}字)`);
                } catch (e) {
                    showStatusMessage('自定义码表加载失败，请重新上传', { isError: true });
                }
            } else {
                showStatusMessage('请先上传码表文件', { isError: true });
            }
        } else if (PREDEFINED_DICTS[selection]) {
            dictionary = {};
            await fetchRemoteDict(PREDEFINED_DICTS[selection]);
        }
        updateStats();
    }

    function startPracticeSession() {
        const text = DOM.practiceTextInput.value;
        practiceSet = [...new Set(text.replace(/\s/g, ''))].filter(c => /[\u4e00-\u9fff]/.test(c) && dictionary[c]);
        
        if (practiceSet.length === 0) {
            showStatusMessage('没有可练习的字符，请检查文本和码表', { isError: true });
            return;
        }
        
        sessionMistakeQueue = [];
        sessionCorrectCount = 0;
        sessionWrongCount = 0;
        
        // Hide setup, show practice (keep stats visible)
        document.querySelectorAll('.setup-section').forEach(el => el.style.display = 'none');
        DOM.sessionStats.style.display = 'block';
        updateSessionStats();
        DOM.inputArea.style.display = 'block';
        DOM.exitPracticeBtn.style.display = 'block';
        
        nextCharacter();
        DOM.typingInput.focus();
    }

    function nextCharacter() {
        currentCharacter = getNextChar();
        DOM.characterDisplay.textContent = currentCharacter;
        DOM.characterDisplay.classList.remove('app-title');
        DOM.typingInput.value = '';
        DOM.typingInput.focus();
    }

    function exitPractice() {
        // Show setup, hide practice
        document.querySelectorAll('.setup-section').forEach(el => el.style.display = 'flex');
        const gridSection = document.querySelector('.setup-section[style*="grid"]');
        if (gridSection) gridSection.style.display = 'grid';
        document.getElementById('stats').style.display = 'block';
        DOM.sessionStats.style.display = 'none';
        DOM.inputArea.style.display = 'none';
        DOM.exitPracticeBtn.style.display = 'none';
        DOM.characterDisplay.textContent = '码上生花';
        DOM.characterDisplay.classList.add('app-title');
        DOM.hintDisplay.textContent = '';
        updateStats();
    }

    function clearProgress() {
        const profileName = DOM.dictSelect.options[DOM.dictSelect.selectedIndex].text;
        if (confirm(`确定要清空「${profileName}」的所有练习进度吗？此操作不可恢复。`)) {
            currentProfile = {};
            saveCurrentProfileProgress();
            showStatusMessage('进度已清空', { isSuccess: true });
            updateStats();
        }
    }

    DOM.textSelect.addEventListener('change', () => {
        localStorage.setItem('lastTextSelection', DOM.textSelect.value);
        updateUIForSelection();
        updateStats();
    });
    DOM.practiceTextInput.addEventListener('input', updateStats);

    // Extract name from YAML header (between --- and ...)
    function extractDictName(contents) {
        const lines = contents.split('\n');
        let inHeader = false;
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed === '---') { inHeader = true; continue; }
            if (trimmed === '...') break;
            if (!inHeader) continue;
            const match = trimmed.match(/^name:\s*["']?(.+?)["']?\s*$/);
            if (match) return match[1];
        }
        return null;
    }

    function ensureCustomDictOption(name) {
        const displayName = name || customDictName || '自定义';
        let option = DOM.dictSelect.querySelector('option[value="custom"]');
        if (!option) {
            option = document.createElement('option');
            option.value = 'custom';
            DOM.dictSelect.appendChild(option);
        }
        option.textContent = displayName;
    }

    DOM.dictUpload.addEventListener('change', async (event) => {
        const files = event.target.files; if (!files.length) return;

        // Set profile to custom and load progress
        currentProfileId = 'custom';
        localStorage.setItem('lastDictSelection', 'custom');
        loadCurrentProfileProgress();

        DOM.startPracticeBtn.disabled = true;
        try {
            const readFile = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
            const allContents = await Promise.all(Array.from(files).map(readFile));
            dictionary = {}; // Clear the dictionary cleanly before parsing
            
            // Extract names from all files and join with "+"
            const names = allContents
                .map(contents => extractDictName(contents))
                .filter(name => name);
            customDictName = names.join('+');
            // Save name and content to localStorage for persistence
            localStorage.setItem('customDictName', customDictName);
            localStorage.setItem('customDictContent', JSON.stringify(allContents));
            
            allContents.forEach(contents => parseAndMergeDict(contents));
            
            // Add custom option with name and select it
            ensureCustomDictOption(customDictName);
            DOM.dictSelect.value = 'custom';
            
            const displayName = customDictName || '自定义码表';
            showStatusMessage(`${displayName} 加载完成 (${Object.keys(dictionary).length}字)`);
        } catch(error) {
            showStatusMessage(`码表读取失败: ${error.message}`, { isError: true });
            dictionary = {}; // Ensure dictionary is empty on failure
        } finally {
            DOM.startPracticeBtn.disabled = false;
            updateStats();
        }
    });

    function parseAndMergeDict(contents){const lines=contents.split("\n");let dataSection=!1;for(const line of lines){if("---"===line.trim()){dataSection=!0;continue}if(!dataSection)continue;const trimmedLine=line.trim();if(!trimmedLine||trimmedLine.startsWith("#"))continue;const parts=trimmedLine.split("\t");if(parts.length<2)continue;const char=parts[0],code=parts[1];if(char&&code&&1===char.trim().length){dictionary[char]||(dictionary[char]=[]),dictionary[char].includes(code)||dictionary[char].push(code)}}}
    function flashFeedback(isCorrect){DOM.typingInput.style.borderColor=isCorrect?"var(--success-color)":"var(--danger-color)",isCorrect||DOM.typingInput.classList.add("shake"),setTimeout(()=>{DOM.typingInput.style.borderColor="var(--medium-gray-color)",isCorrect||DOM.typingInput.classList.remove("shake")},500)}
    
    DOM.typingInput.addEventListener("input", (e) => {
        if (!currentCharacter) return;
        const userInput = e.target.value;
        const correctCodes = dictionary[currentCharacter];
        if (!correctCodes) return;

        if (correctCodes.every(code => !code.startsWith(userInput))) {
            return handleInputComplete(false, userInput);
        }
        
        if (correctCodes.includes(userInput)) {
            flashFeedback(true);
            handleInputComplete(true, userInput);
        }
    });

    function exportProgress() {
        const profiles = JSON.parse(localStorage.getItem('codeGlyphProfiles') || '{}');
        const data = {
            version: 1,
            exportDate: new Date().toISOString(),
            profiles: profiles
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `codeglyph-progress-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatusMessage('进度已导出', { isSuccess: true });
    }

    function importProgress(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (data.profiles) {
                    localStorage.setItem('codeGlyphProfiles', JSON.stringify(data.profiles));
                    loadCurrentProfileProgress();
                    updateStats();
                    showStatusMessage('进度已导入', { isSuccess: true });
                } else {
                    throw new Error('Invalid format');
                }
            } catch (error) {
                showStatusMessage('导入失败: 无效的文件格式', { isError: true });
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset input
    }

    DOM.startPracticeBtn.addEventListener('click', startPracticeSession);
    DOM.exitPracticeBtn.addEventListener('click', exitPractice);
    DOM.clearProgressBtn.addEventListener('click', clearProgress);
    DOM.exportProgressBtn.addEventListener('click', exportProgress);
    DOM.dictSelect.addEventListener('change', handleDictSelection);
    DOM.importProgressBtn.addEventListener('click', () => DOM.importFileInput.click());
    DOM.importFileInput.addEventListener('change', importProgress);
    DOM.uploadDictBtn.addEventListener('click', () => DOM.dictUpload.click());
    
    // Theme toggle
    function toggleTheme() {
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
        if (isDark) {
            document.documentElement.removeAttribute('data-theme');
            localStorage.setItem('theme', 'light');
        } else {
            document.documentElement.setAttribute('data-theme', 'dark');
            localStorage.setItem('theme', 'dark');
        }
    }
    DOM.themeToggle.addEventListener('click', toggleTheme);
    
    // Initialize theme
    if (localStorage.getItem('theme') === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
    }
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Esc to exit practice
        if (e.key === 'Escape' && DOM.inputArea.style.display !== 'none') {
            exitPractice();
        }
    });
    
    function initializeApp() {
        const lastDict = localStorage.getItem('lastDictSelection') || 'feidan';
        const lastText = localStorage.getItem('lastTextSelection') || 'custom';
        
        // Restore custom dict name from localStorage
        customDictName = localStorage.getItem('customDictName') || '';
        const hasCustomDict = localStorage.getItem('customDictContent');
        
        // If user has uploaded a custom dict before, add the option
        if (hasCustomDict) {
            ensureCustomDictOption(customDictName);
        }
        
        // Select the appropriate dict
        if (lastDict === 'custom' && hasCustomDict) {
            DOM.dictSelect.value = 'custom';
            handleDictSelection();
        } else if (PREDEFINED_DICTS[lastDict]) {
            DOM.dictSelect.value = lastDict;
            handleDictSelection();
        } else {
            DOM.dictSelect.value = 'feidan';
            handleDictSelection();
        }
        DOM.textSelect.value = lastText;
        
        updateUIForSelection();
        console.log('CodeGlyph Adaptive. Ready.');
    }

    initializeApp();
  </script>
</body>
</html>
